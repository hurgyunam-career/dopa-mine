# Flutter 스타일 가이드

이 문서는 Flutter/Dart 코드의 일관성과 유지보수성을 위한 최소 스타일 규칙을 정의한다.

## 1. 기본 원칙
- 가독성, 예측 가능성, 테스트 용이성을 우선한다.
- 기존 코드 패턴을 먼저 따르고, 새 패턴 도입은 필요한 경우에만 수행한다.
- UI 레이어는 표현/입력 처리에 집중하고, 비즈니스 로직은 Use Case로 위임한다.

## 2. 파일/폴더 규칙
- Feature-first 구조를 따른다: `lib/src/features/{feature}/...`
- 파일명은 `snake_case.dart`를 사용한다.
- 한 파일에는 하나의 주요 책임(주요 위젯/클래스)을 둔다.
- `presentation`, `application`, `domain`, `infrastructure` 경계를 넘는 참조를 피한다.

## 3. 네이밍 규칙
- 클래스/enum: `PascalCase`
- 변수/함수/파라미터: `camelCase`
- 상수: `camelCase` (`const` 적극 활용)
- bool 변수는 `is`, `has`, `can`, `should` 접두어를 우선 사용한다.
- 이벤트 핸들러는 `onXxx`, 내부 액션 메서드는 `_handleXxx` 패턴을 권장한다.

## 4. 위젯 작성 규칙
- 가능한 `StatelessWidget`을 우선하고, 상태가 필요할 때만 상태 위젯/상태관리 도구를 사용한다.
- `build` 메서드가 길어지면 private 위젯/메서드로 분리한다.
- 하드코딩된 간격/색상/텍스트 스타일 사용을 줄이고 프로젝트 토큰/테마를 우선한다.
- 비동기 호출과 예외 처리는 UI에서 직접 처리하지 말고 Use Case/Controller로 위임한다.

## 5. 상태관리/로직 규칙
- 상태 전이는 예측 가능하게 만들고, UI는 상태를 소비만 하도록 유지한다.
- 화면별 비즈니스 판단(검증, 정책 분기, 계산)은 `application` 또는 `domain`으로 이동한다.
- DTO/Model을 UI에 직접 노출하지 않고, 필요한 경우 ViewModel/Mapper를 둔다.

## 6. Dart 코드 스타일
- nullable 타입은 필요한 경우에만 사용하고, null 처리 흐름을 명확히 표현한다.
- early return으로 중첩을 줄인다.
- 매직 넘버/문자열은 의미 있는 상수로 추출한다.
- `dynamic` 사용은 최소화하고 구체 타입을 명시한다.

## 7. 에러/로깅 규칙
- 사용자 노출 메시지와 개발용 에러 정보를 분리한다.
- 실패 경로(네트워크, 파싱, 권한 등)를 명시적으로 처리한다.
- `try/catch`에서 예외를 삼키지 않고, 최소한 로그/도메인 에러로 변환한다.

## 8. 포맷/검증
- 커밋 전 `dart format .` 실행을 권장한다.
- 커밋 전 `flutter analyze` 통과를 기본 기준으로 한다.
- 가능하면 변경 코드에 대해 단위 테스트 또는 위젯 테스트를 추가한다.
